---
title: "Journal (reproducible report)"
author: "Alexander Sowarka"
date: "2020-11-30"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: true
    toc_depth: 3
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=TRUE)
```

# Intro to tidyverse Challenge

Last compiled: `r Sys.Date()`

## Given Code
Following given code chunks from the exercise are used:
```{r}
# Data Science at TUHH ------------------------------------------------------
# SALES ANALYSIS ----

# 1.0 Load libraries ----
library(tidyverse)
library(readxl)
library(lubridate)

# 2.0 Importing Files ----
# A good convention is to use the file name and suffix it with tbl for the data structure tibble
bikes_tbl      <- read_excel(path = "00_data/01_bike_sales/01_raw_data/bikes.xlsx")
orderlines_tbl <- read_excel("00_data/01_bike_sales/01_raw_data/orderlines.xlsx")

# Not necessary for this analysis, but for the sake of completeness
bikeshops_tbl  <- read_excel("00_data/01_bike_sales/01_raw_data/bikeshops.xlsx")

# 3.0 Examining Data ----


# 4.0 Joining Data ----
bike_orderlines_joined_tbl <- orderlines_tbl %>%
  left_join(bikes_tbl, by = c("product.id" = "bike.id")) %>%
  left_join(bikeshops_tbl, by = c("customer.id" = "bikeshop.id"))

# Examine the results with glimpse()
bike_orderlines_joined_tbl %>% glimpse()

# 5.0 Wrangling Data ----
# All actions are chained with the pipe already. You can perform each step separately and use glimpse() or View() to validate your code. Store the result in a variable at the end of the steps.
bike_orderlines_wrangled_tbl <- bike_orderlines_joined_tbl %>%
  # 5.1 Separate category name
separate(col    = category,
         into   = c("category.1", "category.2", "category.3"),
         sep    = " - ") %>%

# 5.2 Add the total price (price * quantity) 
# Add a column to a tibble that uses a formula-style calculation of other columns
mutate(total.price = price * quantity) %>%

# 5.3 Optional: Reorganize. Using select to grab or remove unnecessary columns
# 5.3.1 by exact column name
select(-...1, -gender) %>%

# 5.3.2 by a pattern
# You can use the select_helpers to define patterns. 
# Type ?ends_with and click on Select helpers in the documentation
select(-ends_with(".id")) %>%

# 5.3.3 Actually we need the column "order.id". Let's bind it back to the data
bind_cols(bike_orderlines_joined_tbl %>% select(order.id)) %>% 

# 5.3.4 You can reorder the data by selecting the columns in your desired order.
# You can use select_helpers like contains() or everything()
select(order.id, contains("order"), contains("model"), contains("category"),
       price, quantity, total.price,
       everything()) %>%

# 5.4 Rename columns because we actually wanted underscores instead of the dots
# (one at the time vs. multiple at once)
rename(bikeshop = name) %>%
set_names(names(.) %>% str_replace_all("\\.", "_"))
```

## Data Wrangling

For the challenge first the data wrangling needs to be adapted to separate the location attribute into city and state:

```{r}
bike_orderlines_wrangled_tbl <- bike_orderlines_wrangled_tbl %>%
# 5.5 Separate Location into State and City
separate(col    = location,
         into   = c("city", "state"),
         sep    = ", " )
bike_orderlines_wrangled_tbl
```

## Buiseness Insights - Sales by State
### Data Manipulation
The data must be grouped by the new created state column and then the sales must be summarised. This results in the sales per state.
```{r}
sales_by_loc_tbl <- bike_orderlines_wrangled_tbl %>%
  
# Select state and price
select(state, total_price) %>%

# Group by State
group_by(state) %>%
summarise(sales = sum(total_price)) %>%
ungroup() %>%

# Format $ Text
mutate(sales_text = scales::dollar(sales, big.mark = ".", 
                                   decimal.mark = ",", 
                                   prefix = "", 
                                   suffix = " €"))

sales_by_loc_tbl
```

### Data Visualization
For plotting the following code can be used:
```{r, fig.width=10, fig.height=7}
sales_by_loc_tbl %>%
  
# Setup canvas with the columns year (x-axis) and sales (y-axis)
ggplot(aes(x = state, y = sales)) +

# Geometries
geom_col(fill = "#2DC6D6") + # Use geom_col for a bar plot

  # Theme
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +

# Formatting
scale_y_continuous(labels = scales::dollar_format(big.mark = ".", 
                                                  decimal.mark = ",", 
                                                  prefix = "", 
                                                  suffix = " €")) +
labs(
  title = "Revenue by State",
  x = "State", # Override defaults for x and y
  y = "Revenue"
)
```

## Buiseness Insights - Sales by State and Year
### Data Manipulation
The data must be grouped by the new created state column and newly created year column and then the sales must be summarised. This results in the sales per state and year.
```{r}
sales_by_loc_year_tbl <- bike_orderlines_wrangled_tbl %>%
  
# Select state and price and add a year
select(order_date, state, total_price) %>%
mutate(year = year(order_date)) %>%

# Group by State
group_by(year, state) %>%
summarise(sales = sum(total_price)) %>%
ungroup() %>%

# Format $ Text
mutate(sales_text = scales::dollar(sales, big.mark = ".", 
                                   decimal.mark = ",", 
                                   prefix = "", 
                                   suffix = " €"))

sales_by_loc_year_tbl  
```

### Data Visualization
For plotting the following code can be used:
```{r, fig.width=10, fig.height=7}
sales_by_loc_year_tbl %>%
  
  # Setup canvas with the columns year (x-axis) and sales (y-axis)
  ggplot(aes(x = year, y = sales, fill = state)) +
  
  # Geometries
  geom_col() + # Use geom_col for a bar plot
  
  # Facet
  facet_wrap(~ state) +
  
  # Theme
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  
  # Formatting
  scale_y_continuous(labels = scales::dollar_format(big.mark = ".", 
                                                    decimal.mark = ",", 
                                                    prefix = "", 
                                                    suffix = " €")) +
  labs(
    title = "Revenue by State",
    x = "", # Override defaults for x and y
    y = "Revenue",
    fill = "State"
  )
```

# Data Acquisition Challenge


## API Challeng
## Used Libs
```{r}
#include packages
library(httr)
library(glue)
library(tidyverse)
library(jsonlite)
library(rvest)     # HTML Hacking & Web Scraping
library(xopen)     # Quickly opening URLs
library(stringi)   # character string/text processing
# 1.1 COLLECT PRODUCT FAMILIES ----
```

## Chuck Norris API
In the following jokes from the Chuck Norris Web API are requested (https://api.chucknorris.io/). First the call to the API is wrapped in a function and the response is checked for its format. It is a normal JSON object.
```{r}
# Wrapped Chuck Norris API into a function
chuck_api <- function(path) {
  url <- modify_url(url = "https://api.chucknorris.io", path = glue("/jokes{path}"))
  resp <- GET(url)
  stop_for_status(resp) # automatically throws an error if a request did not succeed
  return (resp)
}
  #check response code
  resp <- chuck_api("/random")
  resp
  
  #check content
  resp %>% 
    .$content %>% 
    rawToChar()
    

```

Using this API one can define a function to directly get a random joke from a requested JSON Object.
```{r}
# function to get random joke from API
get_joke <- function() {
  joke_json <- chuck_api("/random") %>% 
  .$content %>% 
  rawToChar() %>% 
  fromJSON()
  return (joke_json$value)
}

get_joke()
```

The site offers also different categories for jokes.
```{r}
content(chuck_api("/categories"), as = "parsed")
```

With the following query you can directly get a joke from the "dev" category.
```{r}
category="dev"
content(chuck_api(glue("/random?category={category}")), as = "parsed")%>% 
  .$value
```

## Web Scraping of Radon
In the following data about the bicycles from Radon is retrieved for all available main categories from theit website. First we retrieve all main categories from their site (https://www.radon-bikes.de/en/). Instead of using the banner at top further the buttons further down are used to identify the categories:
```{r}
url_home          <- "https://www.radon-bikes.de/en/"

# Read in the HTML for the entire webpage
html_home         <- read_html(url_home)

# Web scrape the ids for the families
radon_family_tbl <- html_home %>%
  
  # Get the nodes for the families ...
  html_nodes(css = ".a-panel--light") %>%
  html_nodes(css = ".a-button--margin-top-small") %>%
  html_attr('href') %>%
  
  # Convert vector to tibble
  enframe(name = "position", value = "subdirectory") %>%
  
  #filter other urls
  filter(!(subdirectory %>% str_detect("www."))) %>%

  # Add the domain, because we will get only the subdirectories
   mutate(
    url = glue("https://www.radon-bikes.de{subdirectory}")
  ) %>%

  # Some categories are listed multiple times.
  # We only need unique values
  distinct(url)


radon_family_tbl
```

Some categories like E-bike are further divided into subcategories. They are directly retrieved from buttons on the site of the main category. The following function gives all relevant links to the subcategories of a main category. For a main catefory without a subcategory only the main category is returned again. Example usage is also given in the code.

```{r}
#function for bike dubcategories
get_bike_data_sub_category <- function(url) {
  sub_node <- read_html(url) %>%
    
  #Check for link to subcategory
  html_nodes(css = ".m-teaser-grid__linkcontainer") %>%
  html_attr('href') %>%
  
  # Convert vector to tibble
  enframe(name = "position", value = "subdirectory") %>%
  mutate(
      url = glue("https://www.radon-bikes.de{subdirectory}")
    ) %>%
    
    # Some categories are listed multiple times.
    # We only need unique values
  distinct(url)
  
  if (dim(sub_node)[1] != 0)
    return (sub_node)
  else
    return (tibble(url))
}



sub_node <- get_bike_data_sub_category(radon_family_tbl$url[1])
sub_node
sub_node <- get_bike_data_sub_category(radon_family_tbl$url[2])
sub_node
```

Attaching "bikegrid" to the url of a category leads to having an overview of all available bicycles for this category. The following function then returns a link to all individual bicycles of a (sub-)categorty. Using the ".gearhub-1" css also automatically filters out any non bicycle (as they dont have gears)


```{r}
get_bike_data_url<- function(url) {
  print(url)
  # All bikes are under bikegrid
  all_bike_html <- glue("{url}bikegrid/")
  bike_url <- read_html(all_bike_html) %>%
    
    #Only bikes gave gears
    html_nodes(css = ".gearhub-1") %>%
    html_nodes(css = "a") %>%
    html_attr('href') %>%
    # 
    # Convert vector to tibble
    enframe(name = "position", value = "subdirectory") %>%
    mutate(
      url = glue("https://www.radon-bikes.de{subdirectory}")
    ) %>%
    
    # Some categories are listed multiple times.
    # We only need unique values
    distinct(url)
  return (bike_url)
}

bike_data_url <- get_bike_data_url("https://www.radon-bikes.de/en/mountainbike/hardtail/")
bike_data_url
```

The following function can then retrieve data for an individual bicycle. The following data is retrieved. Name (retrieved from a heading inside the html), the description (from a html paragraph), availability and price. Availability and price is retrieved from a regex in part of a script of the html
```{r}
get_bike_data <-function(url, category) {
  print(url)
  bike_html <- read_html(url)
  bike_name <- 
    bike_html %>%
    
    #Only bikes gave gears
    html_node(css = ".a-heading--medium") %>%
    html_text()
  
  bike_descr_text <- bike_html %>%
    
    #Only bikes gave gears
    html_node(css = ".a-paragraph--bigger") %>%
    html_text()
  
  bike_script_text <- bike_html %>%
    
    #Only bikes gave gears
    html_nodes(css = ".mod-bikedetail") %>%
    
    #get first script node
    html_node(css = "script") %>%
    html_text()
  
  
  available <- stringr::str_extract(bike_script_text, "availability.*?\\{.*?\\}") %>%
    str_detect("true")
  price <- stringr::str_match(bike_script_text, "eur.*?price.*?(\\d+)")
  price <- price[2]
  
    
  return (tibble(name =  bike_name,category = category, available = available, price = as.numeric(price), descr = bike_descr_text, url = url))
}

bike_data <- get_bike_data("https://www.radon-bikes.de/en/mountainbike/hardtail/jealous/jealous-80-2021/", "a")
```

In the last part we put all functions together in a wrapper function to retrieve all data for a category. The category for the tavle is retrieved from the url. First the urls of the subcategories is retrieved. Then the urls of all bicycles, then the additional data from the bicycle pages. The subcategory is discarded as information and only the main category is kept. This function can then be used to retrieve data from the complete website. This code is not executed because of the long runtime.
```{r eval=FALSE}
get_bike_data_per_cat <- function(url) {
  category <- url %>%
    str_replace(url_home,"") %>%
    str_replace("/","")
  url_per_subcat_vec <- get_bike_data_sub_category(url) %>% pull(url)
  url_per_bike <- url_per_subcat_vec %>% map(get_bike_data_url) %>% bind_rows %>% pull(url)

  bike_data_cat_list <- url_per_bike %>% map(get_bike_data, category = category)
  return (bind_rows(bike_data_cat_list))
}


#plan("multiprocess")
radon_bike_lst <- radon_family_tbl %>% pull(url) %>% map(get_bike_data_per_cat)
radon_bike_tbl <- radon_bike_lst %>% bind_rows()
```

The final data is displayes using saved data of a previous run
```{r}
web_scraping_radon_data <- readRDS("H:/Uni/Buiseness Data Science/Repo/WS20_Repo/web_scraping_radon_data.rds")
View(web_scraping_radon_data)
```
